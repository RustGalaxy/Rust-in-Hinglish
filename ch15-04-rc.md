## `Rc<T>`, Reference Counted Smart Pointer

Zyadatar cases mein, ownership saaf hoti hai: aapko theek se pata hota hai ki kaun sa variable kisi di gayi value ka maalik hai. Lekin, aise bhi cases hote hain jab ek hi value ke multiple owners ho sakte hain. Udaharan ke liye, graph data structures mein, multiple edges ek hi node ko point kar sakti hain, aur woh node unn sabhi edges ka owner maana jaata hai jo use point karti hain. Ek node ko tab tak clean up nahi karna chahiye jab tak us par koi edge point na kar rahi ho.

Multiple ownership ko sambhav banane ke liye, Rust mein `Rc<T>` naam ka ek type hai, jo *reference counting* ka short form hai. `Rc<T>` type ek value ke references ki ginti ka track rakhta hai, jisse yeh tay hota hai ki value abhi bhi istemal mein hai ya nahi. Agar kisi value ke zero references hain, toh us value ko bina kisi reference ko invalid kiye clean up kiya ja sakta hai.

`Rc<T>` ko ek family room mein rakhe TV ki tarah samjhein. Jab ek vyakti TV dekhne aata hai, toh woh use on karta hai. Doosre log bhi kamre mein aakar TV dekh sakte hain. Jab aakhri vyakti kamre se jaata hai, toh woh TV band kar deta hai kyunki ab use koi istemal nahi kar raha hai. Agar koi TV tab band kar de jab doosre log abhi bhi dekh rahe hon, toh bache hue TV dekhne walon mein halla ho jayega\!

Hum `Rc<T>` type ka istemal tab karte hain jab humein heap par kuch data allocate karna ho jise hamare program ke multiple hisse **padh** (read) sakein, aur hum compile time par yeh nahi bata sakte ki kaun sa hissa data ka istemal sabse aakhir mein khatam karega. Agar humein pata hota ki kaun sa hissa aakhir mein khatam karega, toh hum bas us hisse ko data ka owner bana dete, aur compile time par lagu hone waale normal ownership rules kaam karte.

Dhyan dein ki `Rc<T>` sirf **single-threaded** scenarios mein istemal ke liye hai. Jab hum Chapter 16 mein concurrency par charcha karenge, tab hum multithreaded programs mein reference counting kaise karte hain, yeh cover karenge.

-----

### `Rc<T>` ka Upyog Data Share Karne Ke Liye

Aaiye hum Listing 15-5 ke apne cons list example par wapas chalte hain. Yaad karein ki humne use `Box<T>` ka istemal karke define kiya tha. Is baar, hum do lists banayenge jo dono ek teesri list ka ownership share karti hain. Conceptually, yeh Figure 15-3 jaisa dikhta hai:

\<span class="caption"\>Figure 15-3: Do lists, `b` aur `c`, ek teesri list, `a`, ka ownership share kar rahi hain\</span\>

Hum list `a` banayenge jisme 5 aur phir 10 hoga. Phir hum do aur lists banayenge: `b` jo 3 se shuru hoti hai aur `c` jo 4 se shuru hoti hai. Dono `b` aur `c` lists phir `a` list par jaari rahengi jisme 5 aur 10 hai. Doosre shabdon mein, dono lists us pehli list ko share karengi jisme 5 aur 10 hai.

Is scenario ko `Box<T>` ke saath `List` ki definition ka istemal karke implement karne ki koshish kaam nahi karegi, jaisa ki Listing 15-17 mein dikhaya gaya hai:

\<span class="filename"\>Filename: src/main.rs\</span\>

```rust,ignore
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

\<span class="caption"\>Listing 15-17: Yeh dikhate hue ki humein `Box<T>` ka istemal karke do lists rakhne ki anumati nahi hai jo teesri list ka ownership share karne ki koshish karti hain\</span\>

Jab hum is code ko compile karte hain, toh humein yeh error milta hai:

```text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                               - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

`Cons` variants apne paas rakhe data ke owner hote hain, isliye jab hum `b` list banate hain, toh `a` `b` mein **move** ho jaata hai aur `b` `a` ka owner ban jaata hai. Phir, jab hum `c` banate samay `a` ko dobara istemal karne ki koshish karte hain, toh humein anumati nahi milti kyunki `a` move ho chuka hai.

Hum `Cons` ki definition ko references hold karne ke liye badal sakte the, lekin phir humein lifetime parameters batane padte. Lifetime parameters batakar, hum yeh specify kar rahe hote ki list ka har element kam se kam poori list tak zinda rahega. Borrow checker humein `let a = Cons(10, &Nil);` compile nahi karne deta, kyunki temporary `Nil` value `a` ke uska reference lene se pehle hi drop ho jaati.

Iske bajaye, hum `List` ki apni definition ko `Box<T>` ki jagah `Rc<T>` ka istemal karne ke liye badal denge, jaisa ki Listing 15-18 mein dikhaya gaya hai. Har `Cons` variant ab ek value aur ek `Rc<T>` hold karega jo ek `List` ko point karta hai. Jab hum `b` banayenge, `a` ka ownership lene ke bajaye, hum `a` ke `Rc<List>` ko **clone** karenge, jisse references ki sankhya ek se do ho jayegi aur `a` aur `b` us `Rc<List>` ke data ka ownership share kar sakenge. Hum `c` banate samay bhi `a` ko clone karenge, jisse references ki sankhya do se teen ho jayegi. Har baar jab hum `Rc::clone` call karte hain, `Rc<List>` ke andar ke data ka reference count badh jayega, aur data tab tak clean up nahi hoga jab tak uske zero references na ho jayein.

\<span class="filename"\>Filename: src/main.rs\</span\>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

\<span class="caption"\>Listing 15-18: `List` ki ek definition jo `Rc<T>` ka istemal karti hai\</span\>

Humein `Rc<T>` ko scope mein laane ke liye ek `use` statement add karna hoga kyunki yeh prelude mein nahi hai. `main` mein, hum 5 aur 10 wali list banate hain aur use `a` mein ek naye `Rc<List>` mein store karte hain. Phir jab hum `b` aur `c` banate hain, hum `Rc::clone` function call karte hain aur `a` mein `Rc<List>` ka reference as an argument pass karte hain.

Hum `Rc::clone(&a)` ke bajaye `a.clone()` call kar sakte the, lekin Rust ka convention is case mein `Rc::clone` ka istemal karna hai. `Rc::clone` ka implementation saare data ki **deep copy** nahi banata jaise ki zyadatar types ke `clone` implementations karte hain. `Rc::clone` ka call sirf reference count ko badhata hai, jisme zyada samay nahi lagta. Data ki deep copies mein bahut samay lag sakta hai. Reference counting ke liye `Rc::clone` ka istemal karke, hum deep-copy wale clones aur reference count badhane wale clones ke beech aasaani se antar kar sakte hain. Code mein performance problems dhoondhte samay, humein sirf deep-copy clones par dhyan dena hota hai aur `Rc::clone` ke calls ko ignore kar sakte hain.

-----

### `Rc<T>` ko Clone Karne se Reference Count Badhta Hai

Aaiye hum apne working example Listing 15-18 ko badlein taaki hum dekh sakein ki reference counts kaise badalte hain jab hum `a` mein `Rc<List>` ke references banate aur drop karte hain.

Listing 15-19 mein, hum `main` ko badalenge taaki list `c` ke around ek inner scope ho; tab hum dekh sakte hain ki `c` ke scope se bahar jaane par reference count kaise badalta hai.

\<span class="filename"\>Filename: src/main.rs\</span\>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

\<span class="caption"\>Listing 15-19: Reference count ko print karna\</span\>

Program ke har us point par jahan reference count badalta hai, hum reference count print karte hain, jise hum `Rc::strong_count` function call karke prapt kar sakte hain. Is function ka naam `strong_count` hai na ki `count` kyunki `Rc<T>` type mein ek `weak_count` bhi hota hai; hum "Preventing Reference Cycles" section mein dekhenge ki `weak_count` ka kya istemal hai.

Yeh code neeche diya gaya output print karta hai:

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

Hum dekh sakte hain ki `a` mein `Rc<List>` ka shuruaati reference count 1 hai; phir har baar jab hum `clone` call karte hain, count 1 se badh jaata hai. Jab `c` scope se bahar jaata hai, toh count 1 se kam ho jaata hai. Humein reference count kam karne ke liye koi function call nahi karna padta jaise humein `Rc::clone` call karna padta hai reference count badhane ke liye: `Drop` trait ka implementation reference count ko automatically kam kar deta hai jab `Rc<T>` value scope se bahar jaati hai.

Is example mein hum jo nahi dekh pa rahe hain, woh yeh hai ki jab `b` aur phir `a` `main` ke end mein scope se bahar jaate hain, toh count 0 ho jaata hai, aur `Rc<List>` us samay poori tarah se clean up ho jaata hai. `Rc<T>` ka istemal ek hi value ko multiple owners rakhne ki anumati deta hai, aur count yeh sunishchit karta hai ki value tab tak valid rahe jab tak koi bhi owner मौजूद hai.

Immutable references ke zariye, `Rc<T>` aapko apne program ke multiple parts ke beech data share karne ki anumati deta hai, sirf padhne (reading) ke liye. Agar `Rc<T>` aapko multiple mutable references rakhne ki anumati deta, toh aap Chapter 4 mein bataye gaye borrowing rules mein se ek ka ullanghan kar sakte hain: ek hi jagah par multiple mutable borrows data races aur inconsistencies paida kar sakte hain. Lekin data ko mutate kar paana bahut upyogi hai\! Agle section mein, hum interior mutability pattern aur `RefCell<T>` type par charcha karenge jise aap `Rc<T>` ke saath is immutability pratibandh se nipatne ke liye istemal kar sakte hain.
